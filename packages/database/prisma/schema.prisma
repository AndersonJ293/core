datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
  previewFeatures = ["tracing"]
}

model User {
  id    String @id @default(cuid())
  email String @unique

  authenticationMethod      AuthenticationMethod
  authenticationProfile     Json?
  authenticationExtraParams Json?
  authIdentifier            String?              @unique

  displayName String?
  name        String?
  avatarUrl   String?

  memoryFilter String? // Adding memory filter instructions

  admin Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  marketingEmails       Boolean @default(true)
  confirmedBasicDetails Boolean @default(false)

  referralSource String?

  personalAccessTokens PersonalAccessToken[]
  InvitationCode       InvitationCode?       @relation(fields: [invitationCodeId], references: [id])
  invitationCodeId     String?
  Space                Space[]
  Workspace            Workspace?
}

model Workspace {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deleted   DateTime?

  name String
  slug String  @unique
  icon String?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])
}

enum AuthenticationMethod {
  GOOGLE
}

/// Used to generate PersonalAccessTokens, they're one-time use
model AuthorizationCode {
  id String @id @default(cuid())

  code String @unique

  personalAccessToken   PersonalAccessToken? @relation(fields: [personalAccessTokenId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  personalAccessTokenId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Used by User's to perform API actions
model PersonalAccessToken {
  id String @id @default(cuid())

  /// If generated by the CLI this will be "cli", otherwise user-provided
  name String

  /// This is the token encrypted using the ENCRYPTION_KEY
  encryptedToken Json

  /// This is shown in the UI, with ********
  obfuscatedToken String

  /// This is used to find the token in the database
  hashedToken String @unique

  user   User   @relation(fields: [userId], references: [id])
  userId String

  revokedAt      DateTime?
  lastAccessedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorizationCodes AuthorizationCode[]
}

model InvitationCode {
  id   String @id @default(cuid())
  code String @unique

  users User[]

  createdAt DateTime @default(now())
}

// Space model for user workspaces
model Space {
  id          String  @id @default(cuid())
  name        String
  description String?
  autoMode    Boolean @default(false)

  // Relations
  user   User   @relation(fields: [userId], references: [id])
  userId String

  // Space's enabled entities
  enabledEntities SpaceEntity[]

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  IngestionQueue IngestionQueue[]
}

// Entity types that can be stored in the memory plane
model Entity {
  id       String @id @default(cuid())
  name     String @unique // e.g., "User", "Issue", "Task", "Automation"
  metadata Json // Store field definitions and their types

  // Relations
  spaceEntities SpaceEntity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Junction table for Space-Entity relationship (what entities are enabled in each space)
model SpaceEntity {
  id String @id @default(cuid())

  // Relations
  space   Space  @relation(fields: [spaceId], references: [id])
  spaceId String

  entity   Entity @relation(fields: [entityId], references: [id])
  entityId String

  // Custom settings for this entity in this space
  settings Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([spaceId, entityId])
}

// Queue for processing ingestion tasks
model IngestionQueue {
  id String @id @default(cuid())

  // Relations
  space   Space?  @relation(fields: [spaceId], references: [id])
  spaceId String?

  // Queue metadata
  data     Json // The actual data to be processed
  status   IngestionStatus
  priority Int             @default(0)

  // Error handling
  error      String?
  retryCount Int     @default(0)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  processedAt DateTime?
}

enum IngestionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}
